# 기술적 구현 가이드라인

## 개요
본 문서는 고품질 웹 슬롯 조사 결과를 바탕으로 Slot Maker 프로젝트의 기술적 구현 방향을 제시하는 가이드라인입니다. 현대적인 웹 기술과 모범 사례를 활용하여 경쟁력 있는 슬롯 게임을 제작하기 위한 구체적인 구현 방법을 다룹니다.

## 기술 스택 권장사항

### 핵심 기술
- **Frontend**: TypeScript + HTML5 Canvas
- **Build Tool**: Vite 또는 Webpack 5
- **Package Manager**: npm 또는 yarn
- **Development**: Node.js (LTS 버전)

### 그래픽 및 애니메이션
- **2D 그래픽**: HTML5 Canvas 2D Context
- **3D 그래픽**: Three.js (필요시)
- **애니메이션**: GSAP (GreenSock)
- **파티클 시스템**: Custom 또는 Three.js Particles

### 오디오
- **Web Audio API**: 고품질 오디오 처리
- **Howler.js**: 크로스 브라우저 오디오 호환성
- **음성 압축**: OGG Vorbis, MP3, AAC

### 상태 관리
- **Game State**: Custom State Machine
- **Data Management**: IndexedDB 또는 localStorage
- **Network**: Fetch API 또는 Axios

## 프로젝트 구조

```
slot-maker/
├── src/
│   ├── core/              # 핵심 게임 엔진
│   │   ├── Game.ts        # 메인 게임 클래스
│   │   ├── Renderer.ts    # 렌더링 시스템
│   │   ├── AudioManager.ts # 오디오 관리
│   │   └── InputManager.ts # 입력 처리
│   ├── components/        # 게임 컴포넌트
│   │   ├── Reel.ts        # 릴 시스템
│   │   ├── Symbol.ts      # 심볼 클래스
│   │   ├── UI/            # UI 컴포넌트
│   │   └── Effects/       # 시각 효과
│   ├── systems/           # 게임 시스템
│   │   ├── SpinSystem.ts  # 스핀 로직
│   │   ├── PaylineSystem.ts # 배당 계산
│   │   └── BonusSystem.ts # 보너스 기능
│   ├── assets/            # 게임 에셋
│   │   ├── images/        # 이미지 파일
│   │   ├── audio/         # 오디오 파일
│   │   └── fonts/         # 폰트 파일
│   ├── config/            # 게임 설정
│   │   ├── gameConfig.ts  # 게임 설정
│   │   └── mathModel.ts   # 수학 모델
│   └── utils/             # 유틸리티
│       ├── MathUtils.ts   # 수학 함수
│       └── AssetLoader.ts # 에셋 로더
├── public/                # 정적 파일
├── docs/                  # 문서
└── tests/                 # 테스트 파일
```

## 핵심 시스템 구현

### 1. 게임 엔진 아키텍처

```typescript
// Game.ts
export class Game {
    private canvas: HTMLCanvasElement;
    private renderer: Renderer;
    private audioManager: AudioManager;
    private inputManager: InputManager;
    private gameState: GameState;
    
    constructor(canvasId: string) {
        this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
        this.renderer = new Renderer(this.canvas);
        this.audioManager = new AudioManager();
        this.inputManager = new InputManager(this.canvas);
        this.gameState = new GameState();
        
        this.init();
    }
    
    private init(): void {
        this.setupEventListeners();
        this.loadAssets();
        this.startGameLoop();
    }
    
    private gameLoop = (timestamp: number): void => {
        this.update(timestamp);
        this.render();
        requestAnimationFrame(this.gameLoop);
    };
    
    private update(deltaTime: number): void {
        // 게임 로직 업데이트
        this.gameState.update(deltaTime);
    }
    
    private render(): void {
        // 화면 렌더링
        this.renderer.clear();
        this.renderer.render(this.gameState);
    }
}
```

### 2. 렌더링 시스템

```typescript
// Renderer.ts
export class Renderer {
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;
    
    constructor(canvas: HTMLCanvasElement) {
        this.ctx = canvas.getContext('2d')!;
        this.width = canvas.width;
        this.height = canvas.height;
        
        this.setupCanvas();
    }
    
    private setupCanvas(): void {
        // 고해상도 디스플레이 대응
        const ratio = window.devicePixelRatio || 1;
        this.ctx.canvas.width = this.width * ratio;
        this.ctx.canvas.height = this.height * ratio;
        this.ctx.scale(ratio, ratio);
        
        // 안티앨리어싱 설정
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
    }
    
    public clear(): void {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
    
    public drawSprite(
        image: HTMLImageElement,
        sx: number, sy: number, sw: number, sh: number,
        dx: number, dy: number, dw: number, dh: number
    ): void {
        this.ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
    }
    
    public drawText(
        text: string,
        x: number, y: number,
        font: string, color: string,
        align: CanvasTextAlign = 'left'
    ): void {
        this.ctx.font = font;
        this.ctx.fillStyle = color;
        this.ctx.textAlign = align;
        this.ctx.fillText(text, x, y);
    }
}
```

### 3. 릴 시스템

```typescript
// Reel.ts
export class Reel {
    private symbols: Symbol[] = [];
    private position: number = 0;
    private targetPosition: number = 0;
    private isSpinning: boolean = false;
    private spinSpeed: number = 0;
    
    constructor(
        private x: number,
        private y: number,
        private symbolHeight: number,
        private visibleSymbols: number
    ) {}
    
    public spin(): Promise<void> {
        return new Promise((resolve) => {
            this.isSpinning = true;
            this.spinSpeed = 20; // 초기 속도
            
            // 목표 위치 설정 (랜덤)
            const stopSymbol = Math.floor(Math.random() * this.symbols.length);
            this.targetPosition = stopSymbol * this.symbolHeight;
            
            this.animateSpin(resolve);
        });
    }
    
    private animateSpin(onComplete: () => void): void {
        if (!this.isSpinning) return;
        
        // 릴 위치 업데이트
        this.position += this.spinSpeed;
        
        // 무한 스크롤을 위한 위치 조정
        if (this.position >= this.symbols.length * this.symbolHeight) {
            this.position = 0;
        }
        
        // 감속 로직
        const distance = Math.abs(this.targetPosition - this.position);
        if (distance < 100) {
            this.spinSpeed *= 0.95; // 점진적 감속
            
            if (this.spinSpeed < 0.1) {
                this.position = this.targetPosition;
                this.isSpinning = false;
                onComplete();
                return;
            }
        }
        
        requestAnimationFrame(() => this.animateSpin(onComplete));
    }
    
    public render(renderer: Renderer): void {
        for (let i = 0; i < this.visibleSymbols + 1; i++) {
            const symbolIndex = Math.floor(
                (this.position + i * this.symbolHeight) / this.symbolHeight
            ) % this.symbols.length;
            
            const symbol = this.symbols[symbolIndex];
            const y = this.y + i * this.symbolHeight - 
                      (this.position % this.symbolHeight);
            
            symbol.render(renderer, this.x, y);
        }
    }
}
```

### 4. 오디오 관리 시스템

```typescript
// AudioManager.ts
export class AudioManager {
    private audioContext: AudioContext;
    private sounds: Map<string, AudioBuffer> = new Map();
    private bgMusic: HTMLAudioElement | null = null;
    private soundEnabled: boolean = true;
    private musicEnabled: boolean = true;
    
    constructor() {
        this.audioContext = new (window.AudioContext || 
                                 (window as any).webkitAudioContext)();
    }
    
    public async loadSound(name: string, url: string): Promise<void> {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.sounds.set(name, audioBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${name}`, error);
        }
    }
    
    public playSound(name: string, volume: number = 1): void {
        if (!this.soundEnabled) return;
        
        const buffer = this.sounds.get(name);
        if (!buffer) return;
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = buffer;
        gainNode.gain.value = volume;
        
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        source.start();
    }
    
    public playBackgroundMusic(url: string, loop: boolean = true): void {
        if (!this.musicEnabled) return;
        
        if (this.bgMusic) {
            this.bgMusic.pause();
        }
        
        this.bgMusic = new Audio(url);
        this.bgMusic.loop = loop;
        this.bgMusic.volume = 0.3;
        this.bgMusic.play();
    }
    
    public setSoundEnabled(enabled: boolean): void {
        this.soundEnabled = enabled;
    }
    
    public setMusicEnabled(enabled: boolean): void {
        this.musicEnabled = enabled;
        if (!enabled && this.bgMusic) {
            this.bgMusic.pause();
        }
    }
}
```

### 5. 페이라인 시스템

```typescript
// PaylineSystem.ts
export interface PaylineResult {
    line: number;
    symbols: Symbol[];
    multiplier: number;
    win: number;
}

export class PaylineSystem {
    private paylines: number[][];
    private paytable: Map<string, number[]>;
    
    constructor(paylines: number[][], paytable: Map<string, number[]>) {
        this.paylines = paylines;
        this.paytable = paytable;
    }
    
    public evaluateWins(reels: Symbol[][], bet: number): PaylineResult[] {
        const results: PaylineResult[] = [];
        
        for (let i = 0; i < this.paylines.length; i++) {
            const line = this.paylines[i];
            const symbols = line.map(pos => reels[Math.floor(pos / 3)][pos % 3]);
            
            const winResult = this.checkWin(symbols, bet);
            if (winResult.win > 0) {
                results.push({
                    line: i,
                    symbols: symbols,
                    multiplier: winResult.multiplier,
                    win: winResult.win
                });
            }
        }
        
        return results;
    }
    
    private checkWin(symbols: Symbol[], bet: number): { multiplier: number; win: number } {
        // 와일드 심볼 처리 및 연속 심볼 체크
        const firstSymbol = symbols[0];
        let count = 1;
        
        for (let i = 1; i < symbols.length; i++) {
            if (symbols[i].id === firstSymbol.id || symbols[i].isWild) {
                count++;
            } else {
                break;
            }
        }
        
        // 페이테이블에서 배당 조회
        const payouts = this.paytable.get(firstSymbol.id);
        if (!payouts || count < 3) {
            return { multiplier: 0, win: 0 };
        }
        
        const multiplier = payouts[count - 3] || 0;
        return { multiplier, win: multiplier * bet };
    }
}
```

## 성능 최적화

### 1. 에셋 최적화

```typescript
// AssetLoader.ts
export class AssetLoader {
    private cache: Map<string, any> = new Map();
    private loadingPromises: Map<string, Promise<any>> = new Map();
    
    public async loadImage(url: string): Promise<HTMLImageElement> {
        if (this.cache.has(url)) {
            return this.cache.get(url);
        }
        
        if (this.loadingPromises.has(url)) {
            return this.loadingPromises.get(url);
        }
        
        const promise = new Promise<HTMLImageElement>((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                this.cache.set(url, img);
                this.loadingPromises.delete(url);
                resolve(img);
            };
            img.onerror = reject;
            img.src = url;
        });
        
        this.loadingPromises.set(url, promise);
        return promise;
    }
    
    public preloadAssets(urls: string[]): Promise<void[]> {
        const promises = urls.map(url => this.loadImage(url));
        return Promise.all(promises);
    }
}
```

### 2. 객체 풀링

```typescript
// ObjectPool.ts
export class ObjectPool<T> {
    private pool: T[] = [];
    private createFn: () => T;
    private resetFn: (obj: T) => void;
    
    constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize: number = 10) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }
    
    public get(): T {
        if (this.pool.length > 0) {
            return this.pool.pop()!;
        }
        return this.createFn();
    }
    
    public release(obj: T): void {
        this.resetFn(obj);
        this.pool.push(obj);
    }
}
```

### 3. 프레임레이트 최적화

```typescript
// PerformanceMonitor.ts
export class PerformanceMonitor {
    private fps: number = 60;
    private frameCount: number = 0;
    private lastTime: number = 0;
    private fpsHistory: number[] = [];
    
    public update(currentTime: number): void {
        this.frameCount++;
        
        if (currentTime - this.lastTime >= 1000) {
            this.fps = this.frameCount;
            this.fpsHistory.push(this.fps);
            
            if (this.fpsHistory.length > 10) {
                this.fpsHistory.shift();
            }
            
            this.frameCount = 0;
            this.lastTime = currentTime;
            
            this.adjustQuality();
        }
    }
    
    private adjustQuality(): void {
        const avgFps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
        
        if (avgFps < 45) {
            // 품질 감소
            console.log('Performance optimization: reducing quality');
        } else if (avgFps > 55) {
            // 품질 증가
            console.log('Performance optimization: increasing quality');
        }
    }
}
```

## 반응형 디자인 구현

### 1. 화면 크기 적응

```typescript
// ResponsiveManager.ts
export class ResponsiveManager {
    private canvas: HTMLCanvasElement;
    private baseWidth: number = 1920;
    private baseHeight: number = 1080;
    private currentScale: number = 1;
    
    constructor(canvas: HTMLCanvasElement) {
        this.canvas = canvas;
        this.setupResizeHandler();
    }
    
    private setupResizeHandler(): void {
        window.addEventListener('resize', () => this.resize());
        this.resize(); // 초기 설정
    }
    
    private resize(): void {
        const container = this.canvas.parentElement!;
        const containerRect = container.getBoundingClientRect();
        
        const scaleX = containerRect.width / this.baseWidth;
        const scaleY = containerRect.height / this.baseHeight;
        this.currentScale = Math.min(scaleX, scaleY);
        
        const scaledWidth = this.baseWidth * this.currentScale;
        const scaledHeight = this.baseHeight * this.currentScale;
        
        this.canvas.style.width = `${scaledWidth}px`;
        this.canvas.style.height = `${scaledHeight}px`;
        this.canvas.width = scaledWidth;
        this.canvas.height = scaledHeight;
        
        // 중앙 정렬
        const offsetX = (containerRect.width - scaledWidth) / 2;
        const offsetY = (containerRect.height - scaledHeight) / 2;
        this.canvas.style.left = `${offsetX}px`;
        this.canvas.style.top = `${offsetY}px`;
    }
    
    public getScale(): number {
        return this.currentScale;
    }
    
    public isMobile(): boolean {
        return window.innerWidth < 768;
    }
}
```

### 2. 터치 입력 처리

```typescript
// InputManager.ts
export class InputManager {
    private canvas: HTMLCanvasElement;
    private touches: Map<number, { x: number; y: number }> = new Map();
    
    constructor(canvas: HTMLCanvasElement) {
        this.canvas = canvas;
        this.setupEventListeners();
    }
    
    private setupEventListeners(): void {
        // 마우스 이벤트
        this.canvas.addEventListener('click', this.handleClick.bind(this));
        
        // 터치 이벤트
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // 터치 기본 동작 방지
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault());
        this.canvas.addEventListener('touchmove', (e) => e.preventDefault());
    }
    
    private handleClick(event: MouseEvent): void {
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        this.processInput(x, y);
    }
    
    private handleTouchStart(event: TouchEvent): void {
        for (let i = 0; i < event.changedTouches.length; i++) {
            const touch = event.changedTouches[i];
            const rect = this.canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            this.touches.set(touch.identifier, { x, y });
            this.processInput(x, y);
        }
    }
    
    private processInput(x: number, y: number): void {
        // 입력 처리 로직
        console.log(`Input at: ${x}, ${y}`);
    }
}
```

## 상태 관리

```typescript
// GameState.ts
export enum GamePhase {
    IDLE,
    SPINNING,
    EVALUATING,
    SHOWING_WINS,
    BONUS
}

export class GameState {
    public phase: GamePhase = GamePhase.IDLE;
    public balance: number = 1000;
    public bet: number = 10;
    public totalWin: number = 0;
    public reels: Symbol[][] = [];
    public paylineResults: PaylineResult[] = [];
    
    public canSpin(): boolean {
        return this.phase === GamePhase.IDLE && this.balance >= this.bet;
    }
    
    public startSpin(): void {
        if (!this.canSpin()) return;
        
        this.phase = GamePhase.SPINNING;
        this.balance -= this.bet;
        this.totalWin = 0;
        this.paylineResults = [];
    }
    
    public finishSpin(): void {
        this.phase = GamePhase.EVALUATING;
        // 승리 평가 로직
    }
    
    public addWin(amount: number): void {
        this.totalWin += amount;
        this.balance += amount;
    }
    
    public endEvaluation(): void {
        this.phase = this.totalWin > 0 ? GamePhase.SHOWING_WINS : GamePhase.IDLE;
    }
}
```

## 수학 모델 구현

```typescript
// MathModel.ts
export interface SlotMathModel {
    rtp: number;
    volatility: 'low' | 'medium' | 'high';
    hitFrequency: number;
    maxWin: number;
    reelStrips: number[][];
    paytable: Map<number, number[]>;
}

export class MathEngine {
    private model: SlotMathModel;
    private rng: () => number;
    
    constructor(model: SlotMathModel, rng?: () => number) {
        this.model = model;
        this.rng = rng || Math.random;
    }
    
    public spin(): number[][] {
        const result: number[][] = [];
        
        for (let reel = 0; reel < this.model.reelStrips.length; reel++) {
            const strip = this.model.reelStrips[reel];
            const randomIndex = Math.floor(this.rng() * strip.length);
            
            // 3개 심볼 선택 (현재 위치 기준)
            const reelResult: number[] = [];
            for (let pos = 0; pos < 3; pos++) {
                const index = (randomIndex + pos) % strip.length;
                reelResult.push(strip[index]);
            }
            
            result.push(reelResult);
        }
        
        return result;
    }
    
    public calculateWin(reels: number[][], bet: number): number {
        // 페이라인 승리 계산 로직
        let totalWin = 0;
        
        // 구현 필요: 실제 수학 모델에 따른 승리 계산
        
        return totalWin;
    }
    
    public getExpectedReturn(numberOfSpins: number): number {
        // RTP 검증을 위한 시뮬레이션
        let totalBet = 0;
        let totalWin = 0;
        
        for (let i = 0; i < numberOfSpins; i++) {
            const bet = 10; // 기본 베팅
            const reels = this.spin();
            const win = this.calculateWin(reels, bet);
            
            totalBet += bet;
            totalWin += win;
        }
        
        return totalWin / totalBet;
    }
}
```

## 배포 및 빌드

### Vite 설정

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
    build: {
        rollupOptions: {
            input: {
                main: resolve(__dirname, 'index.html'),
            },
        },
        target: 'es2018',
        minify: 'terser',
        terserOptions: {
            compress: {
                drop_console: true,
                drop_debugger: true,
            },
        },
    },
    server: {
        port: 3000,
        open: true,
    },
    resolve: {
        alias: {
            '@': resolve(__dirname, 'src'),
        },
    },
});
```

### TypeScript 설정

```json
// tsconfig.json
{
    "compilerOptions": {
        "target": "ES2018",
        "module": "ESNext",
        "lib": ["ES2018", "DOM", "DOM.Iterable"],
        "moduleResolution": "node",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "declaration": true,
        "outDir": "dist",
        "baseUrl": ".",
        "paths": {
            "@/*": ["src/*"]
        }
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
}
```

## 테스팅 전략

### 단위 테스트

```typescript
// tests/MathEngine.test.ts
import { MathEngine } from '../src/systems/MathEngine';

describe('MathEngine', () => {
    let mathEngine: MathEngine;
    
    beforeEach(() => {
        const model = {
            rtp: 0.96,
            volatility: 'medium' as const,
            hitFrequency: 0.25,
            maxWin: 5000,
            reelStrips: [
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 2, 3, 4, 5, 6, 7, 8, 9],
            ],
            paytable: new Map(),
        };
        
        mathEngine = new MathEngine(model, () => 0.5); // 고정 시드
    });
    
    test('should generate consistent results with fixed seed', () => {
        const result1 = mathEngine.spin();
        const result2 = mathEngine.spin();
        
        expect(result1).toEqual(result2);
    });
    
    test('should return expected RTP over large number of spins', () => {
        const rtp = mathEngine.getExpectedReturn(100000);
        expect(rtp).toBeCloseTo(0.96, 1);
    });
});
```

## 결론

이 가이드라인을 따라 구현하면 현대적이고 고품질의 웹 슬롯을 제작할 수 있습니다. 핵심은 다음과 같습니다:

1. **모듈화된 아키텍처**: 확장 가능하고 유지보수가 쉬운 구조
2. **성능 최적화**: 60fps 안정성과 빠른 로딩
3. **반응형 디자인**: 모든 기기에서 최적화된 경험
4. **견고한 테스팅**: 신뢰할 수 있는 게임 결과
5. **점진적 개선**: 지속적인 품질 향상

이러한 기술적 기반 위에 창의적인 게임 디자인을 더하면 플레이어들에게 사랑받는 슬롯 게임을 만들 수 있을 것입니다.